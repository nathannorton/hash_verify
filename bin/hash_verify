#!/usr/bin/env ruby
# 
# This app will read a config file, check that it is valid,
# and if so will get the hash of all files defined in the 
# config. Once hashes have been generated it will
# then push them to a mongo instance that we can query
# from there and perform an action against the verified data. 

require 'rubygems'
require 'yaml'
require 'find'
require 'fileutils'

require 'pp'

$LOAD_PATH.unshift File.join(File.dirname(__FILE__), '../lib')
require 'hasher.rb'
require 'database.rb'

CONFIG = YAML.load_file("/etc/hash_verify/hash_verify.conf") unless defined? CONFIG


def verify_hash( files, action )
  files.each do |f|
    case action
      when "delete" then 
        verify_hash_action_delete( f ) 
      when "notify" then 
        verify_hash_action_notify( f ) 
      when "none" then 
        verify_hash_action_none( f ) 
      when "script" then 
        verify_hash_action_script( f )       
    end
  end
end

def verify_hash_action_none( file ) 
  puts "Just sitting here looking inconspicuous"
end 

def verify_hash_action_delete( file )
  pub = convert_to_local_pub( file )

  if check_values( pub ) and  different_host?( pub )
    File.delete file
    puts "The following file has been deleted: #{f}!"

    if (Dir.entries( File.dirname( file ) ) - %w{ .  .. } ).empty?
      puts "dir is empty deleting #{File.dirname( file )}"
      Dir.delete(File.dirname( file ))
    end
  end
end

def verify_hash_action_script( file ) 
  
end 

# TODO: redo check if the different hashing algos are used !!
# possibly send an email to notify 
def verify_hash_action_notify( file )
  hash = @hasher.generate_hash( file )
  res  = @dbase.search_hashes( file ) 

  unless hash.to_s.eql?( res["hash"]  ) 
    
    puts "Host:\t\t#{res["host"]}"
    puts "File:\t\t#{file}"
    puts "Database date:\t#{res["date"]}"
    puts "Current date:\t#{Time.now}"
    puts "Old hash:\t#{res["algo"]},\t#{res["hash"]}"
    puts "New hash:\t#{@hasher.algo},\t#{hash.to_s}"
    puts ""
    
  end

end

# check that the host name we are verifying is not the same as the one that 
# generated the hash value. This is more a sanity check so we dont accidently
# delete files from the source
def different_host?( path )
  @collection.find( "path" => path, "host" => @hostname ).each {|row| return false}
  return true
end



# this will trawl the files listed in the config 
# files. 
# These is 3 cases that are valid:
#   1. file is a directory, recursive set to "n"
#           - this will work on contents of directory
#   2. file is a directory, recursive set to "y"
#           - this will do a recursive generation on all sub dirs
#   3. file is a file, recursive set to "n"
#           - will do only the listed file 
# NOTE: symlinks are skipped
def find_files( config )
  files = []
  config.each do |c|
    verify_config_dirs( c )

    dir = c["directory"].chomp("/")
    recursive = convert_yaml_bools( c["recursive"] ) 
    
    if File.directory? dir 
      unless recursive
        Dir.glob( "#{dir}/*" ).each do |d|
          files << d unless File.directory? d or File.symlink? d
        end
      else
        Dir.glob("#{dir}/**/*").each do |d|
          files << d unless File.directory? d or File.symlink? d 
        end        
      end
    else
      Dir.glob( dir ).each do |d|
        files << d  
      end
    end
  end
  files
end

def clean_yaml( yaml )
  raise "Connection setting no in config" unless yaml['connection']
  raise "Auth section not in config " unless yaml['auth']
  raise "Either action not in config" unless yaml['do_hash'] or yaml['verify'] 
end

# in yaml: "y" "Y" "n" "N" get converted to strings 
# not bools. "yes" "no" however do get passed as  bools 
def convert_yaml_bools( str ) 
  str.downcase! if str.class == String

  return true  if str.eql? "y"
  return false if str.eql? "n"

  str
end


# Check the config is using a relatively sane 
# set of values that will not break the script.
def verify_config_dirs( option )
  dir = option['directory']
  rec = option['recursive']
  act = option['action']

  rec = convert_yaml_bools( rec ) 

  bool = false
  bool = true if rec.class == TrueClass or rec.class == FalseClass 

  raise "Recursive field in config is not either \"y\" or \"n\"" unless bool
  raise "You have specified a file that does not exist, exiting" unless File.file? dir or File.directory? dir
  raise "You have selected recursive in the config, however you supplied a normal file, exiting" if rec and File.file? dir

  valid_actions = ['delete','none','script','notify']
  unless act.nil?
    raise "action is not valid" unless valid_actions.include? act
    @action = act
  end

  return true if rec == false and File.directory? dir
  return true if rec == false and File.file? dir 
  return true if rec and File.directory? dir
  raise "Invalid config file, plese check and try again"
end

def setup_variables #( config ) 
  @dbase = Database

  @hasher = Hasher
  @hasher.algo = Digest::SHA2

end
    
def main() 
  setup_variables()

  clean_yaml( CONFIG )

  # set up the db and make sure we can connect 
  @dbase.setup_db(  CONFIG['connection'], CONFIG['auth'] ) 

  # generate lists of files we need to verify and or publish
  verify_files  = []
  publish_files = []

  verify_files = find_files( CONFIG['verify'] ) unless CONFIG['verify'].nil?
  publish_files = find_files( CONFIG['do_hash'] ) unless CONFIG['do_hash'].nil?

  # publish the hashes we have found
  hashes = @hasher.generate_hashes( publish_files ) unless publish_files.empty?
  @dbase.publish_hashes( hashes ) 
    
  # verify the local hashes to what we have in the db
  verify_hash( verify_files, @action )  unless verify_files.empty?
end


main if __FILE__ == $0 
