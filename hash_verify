#!/usr/bin/env ruby

# 
# This app will read a config file, check that it is valid,
# and if so will get the hash of all files defined in the 
# config. Once hashes have been generated it will
# then push them to a mongo instance that we can query
# from there. 
#
#
# TODO: Does not differentiate between text and binary files yet. 
# TODO: make authentication work
# TODO: need to do exception checking on all file system calls
# TODO: make sure we van not verify against a file we put in the db

require 'rubygems'
require 'digest/md5'
require 'yaml'
require "socket"
require 'find'
require 'fileutils'

# Supress warning only for the import 
# because we are not using bson_ext
OLD_VERB = $VERBOSE
$VERBOSE = nil
require 'mongo'
require 'bson'
$VERBOSE = OLD_VERB


# buffer for maximum size to chunk the hashing, in order to not 
# kill my  machine by loading a many gig files into memory
$BUF = 1024 * 1024 * 1024

CONFIG = YAML.load_file("/etc/hashii.conf") unless defined? CONFIG

# set up the mongo DB connection
def setup_db
    @db = Mongo::Connection.new("mercury").db("hashii")
    raise "failing!!!!"  unless @db.authenticate(@username,@password) 
    @collection = @db.collection('hashes')
end


# publish the hash to the web service
# Currently I am just using a mongodb instance
# to see how it goes...
def publish_hash( hash, filename )
    doc = { "path" => filename,
            "host" => Socket.gethostname.split(".")[0],
            "date" => Time.now,
            "hash" => hash}
    @collection.insert( doc ) 
    puts "The following file has been added to the hash collection: #{filename}"
end

# check values in mongodb
def check_values( file )
    @collection.find( "path" => file).each {|row| return true}
    return false
end

# takes a list of files and verifys them
# TODO: complete verify stuff
def verify_hash( files, action )
    files.each do |f|
        # do action here if it is verified
        pub = convert_to_local_pub(f)
        if check_values(pub) and  different_host?(pub)
            case action
                when "delete" then 
                    File.delete f 
                    puts "The following file has been deleted: #{f}!"
                    # if last file in directory remove remove the directory...
                    if (Dir.entries( File.dirname( f ) ) - %w{ .  .. } ).empty?
                        puts "dir is empty deleting #{File.dirname(f)}"
                        Dir.delete(File.dirname(f))
                    end 
            end
        end
    end
end

# check that the host name we are verifying is not the same as the one that 
# generated the hash value. This is more a sanity check so we dont accidently
# delete files from the source
def different_host?( fn )
    hn = Socket.gethostname.split(".")[0]
    @collection.find( "path" => fn, "host" => hn ).each {|row| return false}
    return true
end


# convert a data directory to a local pub location string 
def convert_to_local_pub( path )
    
    # strip out all but the last part of the file 
    # /data/market/20111101/20111101-any.zblock
    # /pubfs/pub/data/shopping/location4/20110528/20110528-any.block.file
    res = path.split("/").last(2)
    
    hostname = Socket.gethostname.split(".")[0]
    local   = "/local/pub/data/krx/market/"
     
    full = "#{local}#{hostname}/#{res.join("/")}"
end 


# the actual hashing method:
# accepts the filepath (full absolute path)
# and returns a string of the hashed contents
# file_h = Digest::SHA2.new <- can also use sha2 if wanted..
def generate_hash( file_list ) 
    file_list.each do |path|
        unless check_values( path ) 
            file_h = Digest::MD5.new
            File.open(path, 'rb') do |fh|
                while buffer = fh.read($BUF)
                    file_h.update( buffer )
                end
            end
            publish_hash( file_h.to_s, path )
        end
    end

end

# this will trawl the files listed in the config 
# files. 
# These is 3 cases that are valid:
#   1. file is a directory, recursive set to "n"
#           - this will work on contents of directory
#   2. file is a directory, recursive set to "y"
#           - this will do a recursive generation on all sub dirs
#   3. file is a file, recursive set to "n"
#           - will do only the listed file 
# NOTE: symlinks are skipped
def find_files( config )
    files = []
    config.each do |c|
        raise "Config error" unless  verify_config_dirs( c )
        dir = c["directory"].chomp("/")
        rec = unyaml_rec( c["recursive"] ) 
    
    
        if File.directory? dir 
            if rec.eql? "n"
                Dir.glob( "#{dir}/*" ).each do |d|
                    files << d unless File.directory? d or File.symlink? d
                end
            else
                Dir.glob("#{dir}/**/*").each do |d|
                    files << d unless File.directory? d or File.symlink? d 
                end        
            end
        else
            Dir.glob( dir ).each do |d|
                files << d  
            end
        end
    end
    files
end

# This is here because in yaml if you have a string
# "yes" or "YES" or "no" or "NO"
# it will treat as a true or false which will then
# get converted to a string of true or false
# This method just normalises the value
def unyaml_rec( rec )
    # yaml yes converts to true... argh!!
    rec = "y" if rec == true
    rec = "n" if rec == false

    rec = "y" if rec == "true"
    rec = "n" if rec == "false"

    rec.downcase!

    rec = "y" if rec.eql? "yes"
    rec = "n" if rec.eql? "no"

    return rec
end

# check authentication data in config file
def verify_config_auth( option )
    option.each do |k|
        @username = k['username'] unless k['username'].nil?
        @password = k['password'] unless k['password'].nil?
    end
end


# Check the config is using a relatively sane 
# set of values that will not break the script.
def verify_config_dirs( option )
    dir = option['directory']
    rec = option['recursive']
    act = option['action']

    rec = unyaml_rec( rec ) 

    # action stuff 
    # TODO: fix up and make stronger... and actually do something...
    valid_actions = ['delete','none','script']
    unless act.nil?
        raise "action is not valid" unless valid_actions.include? act
    	@action = act
    end

    unless rec.eql? "y" or rec.eql? "n"
        raise "Recursive field in config is not either \"y\" or \"n\""
    end
    unless File.file? dir or File.directory? dir
        raise "You have specified a file that does not exist, exiting" 
    end 
    
    if rec.eql? "y" and File.file? dir
        raise "You have selected recursive in the config, however you supplied a normal file, exiting"
    end

    if rec.eql? "n" and File.directory? dir
        return true
    end 

    if rec.eql? "n" and File.file? dir 
        return true
    end

    if rec.eql? "y" and File.directory? dir
        return true
    end 

    raise "Invalid config file, plese check and try again"
end

    
def main() 

    # check auth is ok 
    verify_config_auth( CONFIG['auth'] )

    # generate lists of files we need to verify and or publish
    verify_files  = []
    publish_files = []
    verify_files = find_files( CONFIG['verify'] ) unless CONFIG['verify'].nil?
    publish_files = find_files( CONFIG['do_hash'] ) unless CONFIG['do_hash'].nil?

    # create the mongo connection
    setup_db    

    # publish the hasehes we have found
    generate_hash( publish_files ) unless publish_files.empty?
    
    # verify the local hashes to what we have in th edb
    # make sure action is not nil... 
    verify_hash( verify_files, @action )  unless verify_files.empty?

end


main if __FILE__ == $0 

