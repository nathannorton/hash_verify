#!/usr/bin/env ruby

# 
# This app will read a config file, check that it is valid,
# and if so will get the hash of all files defined in the 
# config. Once hashes have been generated it will
# then push them to a mongo instance that we can query
# from there. 
#
#
# TODO: Does not differentiate between text and binary files yet. 
# TODO: make authentication work
# TODO: need to do exception checking on all file system calls
# TODO: make sure we van not verify against a file we put in the db

require 'rubygems'
require 'digest/md5'
require 'yaml'
require "socket"
require 'find'
require 'fileutils'
require 'mongo'
require 'bson'

require 'pp'


# buffer for maximum size to chunk the hashing, in order to not 
# kill my  machine by loading a many gig files into memory
$BUF = 1024 * 1024 * 1024

CONFIG = YAML.load_file("/etc/hash_verify/hash_verify.conf") unless defined? CONFIG


# set up the mongo DB connection, use defaults if 
# the connection details in the config file are not set
def setup_db( opts, auth ) 
  port       = ( true && opts['port'] )       || 27017
  server     = ( true && opts['server'] )     || 'localhost'
  database   = ( true && opts['database'] )   || 'hash_verify'
  collection = ( true && opts['collection'] ) || 'hashes'

  username   = ( true && auth['username'] ) || 'hash_verify' 
  password   = ( true && auth['password'] ) || 'hash_password'
  
  db = Mongo::Connection.new( server, port ).db( database )
  raise "Failed to authenticate against the db" \
    unless db.authenticate(username,password) 

  @collection = db.collection( collection )
  db.strict = true 
end


def publish_hash( hash, filename )
  doc = { "path" => filename,
          "host" => Socket.gethostname.split(".")[0],
          "date" => Time.now,
          "hash" => hash}
  @collection.insert( doc ) 
  puts "The following file has been added to the hash collection: #{filename}"
end


def check_values( file )
  @collection.find( "path" => file).each {|row| return true}
  return false
end


# takes a list of files and verifys them
# TODO: complete verify stuff
def verify_hash( files, action )
  files.each do |f|
    # do action here if it is verified
    pub = convert_to_local_pub(f)
    if check_values(pub) and  different_host?(pub)
      case action
        when "delete" then 
          File.delete f 
          puts "The following file has been deleted: #{f}!"
          # if last file in directory remove remove the directory...
          if (Dir.entries( File.dirname( f ) ) - %w{ .  .. } ).empty?
            puts "dir is empty deleting #{File.dirname(f)}"
            Dir.delete(File.dirname(f))
          end 
        end
    end
  end
end

# check that the host name we are verifying is not the same as the one that 
# generated the hash value. This is more a sanity check so we dont accidently
# delete files from the source
def different_host?( fn )
  hn = Socket.gethostname.split(".")[0]
  @collection.find( "path" => fn, "host" => hn ).each {|row| return false}
  return true
end


# convert a data directory to a local pub location string 
def convert_to_local_pub( path )
  # strip out all but the last part of the file 
  # /data/market/20111101/20111101-any.zblock
  # /pubfs/pub/data/shopping/location4/20110528/20110528-any.block.file
  res = path.split("/").last(2)
    
  hostname = Socket.gethostname.split(".")[0]
  local   = "/local/pub/data/krx/market/"
     
  full = "#{local}#{hostname}/#{res.join("/")}"
end 


# the actual hashing method:
# accepts the filepath (full absolute path)
# and returns a string of the hashed contents
# file_h = Digest::SHA2.new <- can also use sha2 if wanted..
def generate_hash( file_list ) 
  file_list.each do |path|
    unless check_values( path ) 
      file_h = Digest::MD5.new
      File.open(path, 'rb') do |fh|
        while buffer = fh.read($BUF)
          file_h.update( buffer )
        end
      end
      publish_hash( file_h.to_s, path )
    end
  end
end

# this will trawl the files listed in the config 
# files. 
# These is 3 cases that are valid:
#   1. file is a directory, recursive set to "n"
#           - this will work on contents of directory
#   2. file is a directory, recursive set to "y"
#           - this will do a recursive generation on all sub dirs
#   3. file is a file, recursive set to "n"
#           - will do only the listed file 
# NOTE: symlinks are skipped
def find_files( config )
  files = []
  config.each do |c|
    dir = c["directory"].chomp("/")
    recursive = convert_yaml_bools( c["recursive"] ) 
    
    if File.directory? dir 
      unless recursive
        Dir.glob( "#{dir}/*" ).each do |d|
          files << d unless File.directory? d or File.symlink? d
        end
      else
        Dir.glob("#{dir}/**/*").each do |d|
          files << d unless File.directory? d or File.symlink? d 
        end        
      end
    else
      Dir.glob( dir ).each do |d|
        files << d  
      end
    end
  end
  files
end

def clean_yaml( yaml )
  raise "Connection setting no in config" unless yaml['connection']
  raise "Auth section not in config " unless yaml['auth']
  raise "Either action not in config" unless yaml['do_hash'] or yaml['verify'] 
end

# in yaml: "y" "Y" "n" "N" get converted to strings 
# not bools. "yes" "no" however do get passed as  bools 
def convert_yaml_bools( str ) 
  str.downcase! if str.class == String

  return true  if str.eql? "y"
  return false if str.eql? "n"

  str
end


# Check the config is using a relatively sane 
# set of values that will not break the script.
def verify_config_dirs( option )
  dir = option['directory']
  rec = option['recursive']
  act = option['action']

  rec = convert_yaml_bools( rec ) 

  bool = false
  bool = true if rec.class == TrueClass or rec.class == FalseClass 

  raise "Recursive field in config is not either \"y\" or \"n\"" unless bool
  raise "You have specified a file that does not exist, exiting" unless File.file? dir or File.directory? dir
  raise "You have selected recursive in the config, however you supplied a normal file, exiting" if rec and File.file? dir

  valid_actions = ['delete','none','script']
  unless act.nil?
    raise "action is not valid" unless valid_actions.include? act
    @action = act
  end

  return true if rec == false and File.directory? dir
  return true if rec == false and File.file? dir 
  return true if rec and File.directory? dir
  raise "Invalid config file, plese check and try again"
end

    
def main() 
  clean_yaml( CONFIG )

  # set up the db and make sure we can connect 
  setup_db( CONFIG['connection'], CONFIG['auth'] )

  # generate lists of files we need to verify and or publish
  verify_files  = []
  publish_files = []
 
  verify_files = find_files( CONFIG['verify'] ) unless CONFIG['verify'].nil?
  publish_files = find_files( CONFIG['do_hash'] ) unless CONFIG['do_hash'].nil?

  # publish the hasehes we have found
  generate_hash( publish_files ) unless publish_files.empty?
    
  # verify the local hashes to what we have in the db
  # make sure action is not nil... 
  verify_hash( verify_files, @action )  unless verify_files.empty?
end


main if __FILE__ == $0 
